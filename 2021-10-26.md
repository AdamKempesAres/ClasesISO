# Apartado pendiente tema anterior
- Registros (logs) del sistema.
  - Formato de los registros: fuente/origen, prioridades (informativos, advertencias, errores, etc.)
  - Herramientas para su monitorización en sistemas libres y propietarios.
  - Gestión: Aplicar filtros, asociar tareas en respuesta a ciertos eventos, etc.

-----------
-----------

# Administración y aseguramiento de la información:
- Sistemas de archivos:
  - Propietarios y libres.
  - Rutas y nombres de archivos. Estructura jerárquica.
- Gestión de sistemas de archivos mediante comandos y entornos gráficos.
- Gestión de enlaces.
- Estructura de directorios de sistemas operativos libres y propietarios.
- Búsqueda de información del sistema mediante comandos y herramientas gráficas.
- Identificación del software instalado mediante comandos y herramientas gráficas.
- Gestión de la información del sistema. Rendimiento. Estadísticas.
- Montaje y desmontaje de dispositivos en sistemas operativos. Automatización.
- En sistemas Windows montar un volumen en una o más carpetas.
- Herramientas de administración de discos. Particiones y volúmenes. Desfragmentación y chequeo.
- Permisos locales de acceso a ficheros y directorios.
- Niveles RAID:
  - Implementación por hardware y por software. Ventajas e inconvenientes.
  - Niveles RAID usados en la actualidad. Características: tolerancia a fallos, número de mínimo de discos necesarios para su implementación, cuántos discos pueden fallar sin perder el servicio, etc.
  - Funciones avanzadas. Unión de niveles RAID más usados como RAID 10, RAID 50 y RAID 60.
- Implementación RAID por software:
  - Operaciones con volúmenes: extender y distribuir.
  - Aumentar la velocidad.
  - Tolerancia a fallos. Simular un fallo de disco para comprobar la tolerancia del sistema.
  - Detectar fallos consultando los registros del sistema.
  - Programar alertas por correo.
- Tipos de copias de seguridad:
  - Locales y Remotas.
  - Herramientas clásicas: copias de seguridad completas, diferenciales e incrementales.
  - Herramientas de sincronización con control de versiones.
- Planes de copias de seguridad y restablecimiento.
- Consideraciones:
    - Dónde realizar las copias de seguridad (backup), locales y remotas.
    - Programación de copias de seguridad: para decidir la programación habrá que tener en cuenta el tiempo asumible de pérdida de datos, si es necesario detener servicios para realizar las copias de seguridad, etc.
    - Espacio necesario, históricos, rotaciones de los medios, etc.
- Responsabilidad de las copias de seguridad. Personas encargadas de revisar las copias de seguridad y restablecerlas si es necesario. Asignar los permisos necesarios a estas personas. 
- Elección del software para realizar los backups. Uso de herramientas estándar o específicas para los datos/servicios a asegurar.
- Probar la integridad de las copias de seguridad:
    - Crear un plan de pruebas. Ventajas del uso de máquinas virtuales para las pruebas de integridad de los backups.
    - Comprobar si los tiempos de restauración son asumibles.
- Crear un plan de restauración:
    - Dónde se restaurarán los datos en caso de fallo físico de discos, servidores, etc.
    - Quien está autorizado para realizar la restauración.
    - Detallar los pasos a realizar.
- Recuperación en caso de fallo del sistema:
  - Responsables de la recuperación, mecanismos para localizar a estas personas.
  - Hardware crítico para la restauración.
  - Medidas a adoptar para mitigar el impacto del fallo.
  - Discos de arranque. Discos de recuperación.
  - Copias de seguridad del sistema. Recuperación del sistema mediante consola. Puntos de recuperación.
- Creación y recuperación de imágenes de servidores.
  - Cuotas de disco. Niveles de cuota y niveles de advertencia.
  - Compresión de datos.

---------------------

# Sistema de archivos

## Introducción a sistema de archivos
https://www.jesusninoc.com/2017/07/04/4-gestion-del-sistema-de-archivos-en-powershell/

# Sistema de archivos: discos

## Comandos para trabajar con discos en PowerShell
https://www.jesusninoc.com/07/04/4-gestion-del-sistema-de-archivos-en-powershell/

# Ejercicio
- Crear varios discos virtuales leyendo desde un fichero la información (nombre), los discos hay que particionarlos y formatearlos. Añadir a cada disco duro información sobre los procesos e hilos que se están ejecutando.
## Ayuda
* https://docs.microsoft.com/es-es/windows/deployment/windows-10-poc 
* https://github.com/jesusninoc/ClasesSOM/blob/master/2019-02-26.md#crear-un-disco-virtual-en-windows
* https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2012-R2-and-2012/gg252593%28v%3dws.11%29
* https://docs.microsoft.com/es-es/windows/deployment/windows-10-poc
* https://github.com/jesusninoc/ClasesSOM/blob/master/2019-02-26.md#ejercicios

## Script
```PowerShell
"lucas" | Out-File .\usuarios.txt -Append

foreach($usuario in gc .\usuarios.txt)
{
    $ruta = "c:\"+$usuario+".vhdx"
    $vhdpath = $ruta
    $vhdsize = 1GB
    New-VHD -Path $vhdpath -Dynamic -SizeBytes $vhdsize | Mount-VHD -Passthru |Initialize-Disk -Passthru | New-Partition -AssignDriveLetter -UseMaximumSize |Format-Volume -FileSystem NTFS -Confirm:$false -Force
}

foreach($unidad in (Get-Partition).DriveLetter)
{
    Get-Process | select name, Threads | Out-File ($unidad+":\informacion.txt")
}
```

----------------

# Ejemplos

## Listar ficheros (partir por -, ejemplo de ficheros 123-10.txt)

```PowerShell
ls '*.txt'
```
```PowerShell
foreach($ficheros in (ls '*.txt').Name)
{
$ficheros.split('-')
}
```
```PowerShell
foreach($ficheros in (ls '*.txt').Name)
{
$ficheros.split('-')[1]
}
```
```PowerShell
foreach($ficheros in (ls '*.txt').Name)
{
$ficheros.split('-')[1].Replace('.txt','')
}
```

--------------
--------------

# Administración y aseguramiento de la información:
- Sistemas de archivos:
  - Propietarios y libres.
  - Rutas y nombres de archivos. Estructura jerárquica.
- Gestión de sistemas de archivos mediante comandos y entornos gráficos.
- Gestión de enlaces.
- Estructura de directorios de sistemas operativos libres y propietarios.
- Búsqueda de información del sistema mediante comandos y herramientas gráficas.
- Identificación del software instalado mediante comandos y herramientas gráficas.
- Gestión de la información del sistema. Rendimiento. Estadísticas.
- Montaje y desmontaje de dispositivos en sistemas operativos. Automatización.
- En sistemas Windows montar un volumen en una o más carpetas.
- Herramientas de administración de discos. Particiones y volúmenes. Desfragmentación y chequeo.
- Permisos locales de acceso a ficheros y directorios.
- Niveles RAID:
  - Implementación por hardware y por software. Ventajas e inconvenientes.
  - Niveles RAID usados en la actualidad. Características: tolerancia a fallos, número de mínimo de discos necesarios para su implementación, cuántos discos pueden fallar sin perder el servicio, etc.
  - Funciones avanzadas. Unión de niveles RAID más usados como RAID 10, RAID 50 y RAID 60.
- Implementación RAID por software:
  - Operaciones con volúmenes: extender y distribuir.
  - Aumentar la velocidad.
  - Tolerancia a fallos. Simular un fallo de disco para comprobar la tolerancia del sistema.
  - Detectar fallos consultando los registros del sistema.
  - Programar alertas por correo.
- Tipos de copias de seguridad:
  - Locales y Remotas.
  - Herramientas clásicas: copias de seguridad completas, diferenciales e incrementales.
  - Herramientas de sincronización con control de versiones.
- Planes de copias de seguridad y restablecimiento.
- Consideraciones:
    - Dónde realizar las copias de seguridad (backup), locales y remotas.
    - Programación de copias de seguridad: para decidir la programación habrá que tener en cuenta el tiempo asumible de pérdida de datos, si es necesario detener servicios para realizar las copias de seguridad, etc.
    - Espacio necesario, históricos, rotaciones de los medios, etc.
- Responsabilidad de las copias de seguridad. Personas encargadas de revisar las copias de seguridad y restablecerlas si es necesario. Asignar los permisos necesarios a estas personas. 
- Elección del software para realizar los backups. Uso de herramientas estándar o específicas para los datos/servicios a asegurar.
- Probar la integridad de las copias de seguridad:
    - Crear un plan de pruebas. Ventajas del uso de máquinas virtuales para las pruebas de integridad de los backups.
    - Comprobar si los tiempos de restauración son asumibles.
- Crear un plan de restauración:
    - Dónde se restaurarán los datos en caso de fallo físico de discos, servidores, etc.
    - Quien está autorizado para realizar la restauración.
    - Detallar los pasos a realizar.
- Recuperación en caso de fallo del sistema:
  - Responsables de la recuperación, mecanismos para localizar a estas personas.
  - Hardware crítico para la restauración.
  - Medidas a adoptar para mitigar el impacto del fallo.
  - Discos de arranque. Discos de recuperación.
  - Copias de seguridad del sistema. Recuperación del sistema mediante consola. Puntos de recuperación.
- Creación y recuperación de imágenes de servidores.
  - Cuotas de disco. Niveles de cuota y niveles de advertencia.
  - Compresión de datos.

---------------------

# Sistema de archivos

## Introducción a sistema de archivos
https://www.jesusninoc.com/2017/07/04/4-gestion-del-sistema-de-archivos-en-powershell/

# Sistema de archivos: discos

## Comandos para trabajar con discos en Linux
```Bash
df -h
sudo fdisk -l /dev/sdb
sudo mkfs.vfat /dev/sdc1
sudo mkfs.ntfs /dev/sdc1
sudo mkfs.ext4 /dev/sdc1
sudo blkid
sudo mkdir mount_name
sudo mount -t auto -v /dev/sdb1 /mnt/mount_name
sudo umount /dev/sdb
```

---------------
---------------

# Examen de noviembre

## Tener en cuenta:
- Utilizar ficheros para leer la información
- Almacenar información en ficheros de log
- Utilizar variables
- Foreach

## Preguntas:
### - Leer identificadores de procesos y comprobar que tienen un proceso
```PowerShell
"7492" | Out-File ids.txt
foreach($id in gc ids.txt)
{
    Get-Process -id $id
}
```

### - Detectar si hay un tipo de proceso y producto de software que se llame "Acrobat"
```PowerShell
Get-Process | select *
Get-Process | select Company
foreach ($proceso in Get-Process | select Company)
{
    $proceso.Company | Select-String "Microsoft"
}
foreach ($proceso in Get-Process | select Company)

{
    $proceso.Company | Select-String "Acrobat"
}
```

### - Detectar que se está consumiendo tráfico de red por parte de un proceso
```PowerShell
Get-WmiObject win32_service | select *
(Get-WmiObject win32_service | select * | Where-Object name -eq "WebClient").ProcessId
Get-Process -id (Get-WmiObject win32_service | select * | Where-Object name -eq "WebClient").ProcessId
```

### - Detectar que un proceso está utilizando el posicinamiento GPS
```PowerShell
Get-Process | select *
Get-Process -name chrome | Select-Object path
Get-WmiObject win32_process | select *
(Get-WmiObject win32_process | select CommandLine).CommandLine | Select-String "gp"
(Get-WmiObject win32_process | select CommandLine).CommandLine | Select-String "gps"
```

-------------
-------------

# Repaso de examen
* https://github.com/jesusninoc/ClasesISO/blob/master/2020-11-05.md#examen-de-noviembre
## Solución complicada
* https://github.com/jesusninoc/ClasesSAD/blob/master/2020-11-06.md#caso-me-est%C3%A1n-espiando

-----------
-----------

#  IF en PowerShell
* https://www.jesusninoc.com/07/02/2-programacion-en-powershell/#Sentencias_condicionales

# Ejemplos con IF

## Pedir al usuario un nombre de usuario y un password
```PowerShell
$usuario=Read-Host "Introduzca nombre de usuario"
$pass=Read-Host "Introduzca nombre de usuario"
$usuario
$pass
```

## Pedir al usuario un nombre de usuario y un password y comprobar si es "juan"

```PowerShell
$usuario=Read-Host "Introduzca nombre de usuario"
$pass=Read-Host "Introduzca nombre de usuario"
$usuario
$pass
if($usuario -eq "juan")
{

}
else
{

}
```

## Introducir un nombre y pass y ver si es correcto

```PowerShell
$usuario=Read-Host "Introduzca nombre de usuario"
$pass=Read-Host "Introduzca nombre de usuario"
$usuario
$pass
if($usuario -eq "hola")
{
"el uusario es hola"
}
else
{
"el usuario no es hola"
}
```

## Introducir pass y ver si es correcto
```PowerShell
$user=Read-Host
$pass=Read-Host
if($user -eq "pepito" -and $pass -eq "secreto")
{
Write-Host $user
}
```

---------------

# Switch en PowerShell
* https://www.jesusninoc.com/2016/08/09/sentencia-condicional-switch/

# Ejemplos
## Ejemplos sobre operaciones con switch
```PowerShell
$a=Read-Host "Introduzca operación"
switch($a){
'+'{
echo Suma
break
}
}
```
## Pedir una operación y si es "suma" realizar una suma
```PowerShell
$a=Read-Host "Introduzca operación"
switch($a){
'+'{
suma
break
}
}

function suma()
{
2+3
}
```

-----------
-----------

# Ejercicios

## Crear dos ficheros TXT, convertirlos a PDF y juntarlos con Poppler
```PowerShell
# Instalar en Ubuntu Poppler 
# $ sudo apt-get install poppler-utils

"pagina 1" | Out-File 01-22-10-2019.txt
"pagina 2" | Out-File 02-22-10-2019.txt

gc .\01-22-10-2019.txt | Out-Printer "Microsoft Print to PDF"
gc .\02-22-10-2019.txt | Out-Printer "Microsoft Print to PDF"

ls *.pdf

wsl ls
wsl pdfunite 01-22-10-2019-P.pdf 02-22-10-2019-P.pdf out.pdf
.\out.pdf

```

## Crear cinco directorios y dentro de cada directorio crear 10 ficheros
```PowerShell
foreach($directorio in 1..5)
{
    New-Item -Name $directorio -WhatIf -ItemType Directory
    foreach($fichero in 1..10)
    {
        New-Item -Path $directorio -Name $fichero -WhatIf -ItemType File 
    }
}
```

## Crear una estructura de directorios
```PowerShell
notepad amigos.txt

mkdir (gc .\amigos.txt)

foreach($elementitos in gc .\amigos.txt)
{
    Set-Location $elementitos
    mkdir "iso","fol","redes"
    cd ..
}
```

## Crear una estructura de directorios
```PowerShell
## 1 -> ISO   -> 1EVA
## 1 -> ISO   -> 2EVA
## 1 -> ISO   -> 3EVA
## 1 -> REDES -> 1EVA
## 1 -> REDES -> 2EVA
## 2 -> ISO   -> 1EVA
## 2 -> ISO   -> 2EVA
## 5

foreach($alumnos in 1..5)
{
    New-Item -Name $alumnos -ItemType Directory -Force
    foreach($materias in "iso","redes","fol")
    {
        New-Item -Name $materias -ItemType Directory -Path $alumnos -Force
        foreach($evaluacion in "1eva","2eva","3eva")
        {
            $ruta = [String]$alumnos + "\" + $materias 
            $ruta 
            New-Item -Name $evaluacion -ItemType Directory -Path $ruta -Force
            Write-Host $alumnos $materias $evaluacion
        }   
    }
}
```

## Crear una estructura de directorios (pero solo los números pares)
```PowerShell
## 2 -> ISO   -> 1EVA
## 2 -> ISO   -> 2EVA

foreach($alumnos in 1..5)
{
    New-Item -Name ($alumnos*2) -ItemType Directory -Force
    foreach($materias in "iso","redes","fol")
    {
        New-Item -Name $materias -ItemType Directory -Path ($alumnos*2) -Force
        foreach($evaluacion in "1eva","2eva","3eva")
        {
            $ruta = [String]($alumnos*2) + "\" + $materias 
            $ruta 
            New-Item -Name $evaluacion -ItemType Directory -Path $ruta -Force
            Write-Host ($alumnos*2) $materias $evaluacion
        }   
    }
}
```

## Crear una estructura de directorios (pero solo los números impares)
```PowerShell
## 1 -> ISO   -> 1EVA
## 3 -> ISO   -> 2EVA

for($alumnos=1;$alumnos -lt 5;$alumnos=$alumnos+2)
{
    New-Item -Name $alumnos -ItemType Directory -Force
    foreach($materias in "iso","redes","fol")
    {
        New-Item -Name $materias -ItemType Directory -Path $alumnos -Force
        foreach($evaluacion in "1eva","2eva","3eva")
        {
            $ruta = [String]$alumnos + "\" + $materias 
            $ruta 
            New-Item -Name $evaluacion -ItemType Directory -Path $ruta -Force
            Write-Host $alumnos $materias $evaluacion
        }   
    }
}
```

## Leer operaciones de un fichero y realizarlas

### Estructura del fichero asignaturas.txt (0 crear fichero, 1 crear directorio)
```
iso,0
aso,1
```

### Leer del fichero que tiene las asignaturas
```PowerShell
$fichero=get-content asignaturas.txt
$fichero | % {
$_
}
```

### Leer del fichero que tiene las asignaturas y obtener solo la operación que hay que realizar
```PowerShell
$fichero=get-content asignaturas.txt
$fichero | % {
$_.split(',')[1]
}
```

### Leer el fichero y detectar la operación a realizar utilizando el switch
```PowerShell
$fichero = Get-Content asignaturas.txt
$fichero | % {
    $operacion = $_.split(",")
    switch($operacion[1]){
        '0'{
            echo "crear fichero"
            New-Item -Name $operacion[0] -ItemType File -Force
            break
        }
        '1'{
            echo "crear directorio"
            mkdir $operacion[0] -Force
            break
        }
    }
}
```

-------------
-------------

# Administración y aseguramiento de la información:
- Sistemas de archivos:
  - Propietarios y libres.
  - Rutas y nombres de archivos. Estructura jerárquica.
- Gestión de sistemas de archivos mediante comandos y entornos gráficos.
- Gestión de enlaces.
- Estructura de directorios de sistemas operativos libres y propietarios.
- Búsqueda de información del sistema mediante comandos y herramientas gráficas.

---------------

# Linux

## A First Script
* https://www.shellscript.sh/first.html

## Ejercicios con ficheros y directorios (Bash)

```Bash
#Crear o modificar un archivo
vi nombre
```
```Bash
#Crear un directorio
mkdir
```
```Bash
#Ver el contenido de un archivo
cat
```
```Bash
#Acceder al contenido de un directorio
cd
```
```Bash
#Listar el contenido de un directorio
ls
```
```Bash
#Ver la estructura de un directorio
tree
```
```Bash
#Eliminar un archivo
rm
```
```Bash
#Eliminar un directorio
rmdir
```
```Bash
#Copiar un archivo o un directorio
cp
```
```Bash
#Mover un archivo o un directorio
mv
```
```Bash
#Renombrar un archivo o un directorio
mv
```
```Bash
#Establecer permisos en un archivo o un directorio
chmod
```
```Bash
#Comprimir y descomprimir un archivo o un directorio
gzip
```
```Bash
#Imprimir un archivo
lpr
```

## Ejercicios propuestos con ficheros y directorios (Bash)

- Crear un directorio para cada usuario
- Crear un fichero para cada usuario
- Añadir contenido a cada fichero creado para cada usuario
- Eliminar un directorio
- Renombrar un directorio
- Mover archivos de una carpeta a otra

## Ejercicios resueltos con ficheros y directorios (Bash)

1. Crear fichero que tenga tu nombre
```Bash	
 	echo Alejandro > fichero.txt
	#-------------------------
	who | awk '{print $1}' > fichero.txt
```
2. Ver el contenido de un fichero cuyo nombre esta guardado en otro fichero
```Bash
	cat `cat fichero.txt`
	#--------------------
	fich1= cat fichero
	cat $fich1
```
3. Listar contenido de un directorio y almacenarlo en un fichero
```Bash	
	ls directorio > listaDeDirectorio.txt
	cat listadeDirectorio.txt
```
4. Eliminar un fichero leyendo el nombre de este desde otro fichero
```Bash
	echo fichero1.txt > fichero2.txt

	rm `cat ficher2.txt`
	#------------------------------
	fic=cat ficher2.txt
	rm $fic
```
5. Eliminar directorio leyendo el nombre desde este desde otro fichero.	
```Bash
	echo directorio > fichero.txt
	
	mkdir `cat fichero.txt`
	
	rm -r `cat fichero.txt`
	#------------------------------
	direc=cat fichero.txt
	
	mkdir $direc
	rm -r $direc
```
6. Comprimir un directorio
```Bash
	gzip fichero
```

------------------

# Ejercicios resueltos con ficheros y directorios (PowerShell)

## Crear directorios con los meses del año
```PowerShell
foreach($mes in 1..12)
{
    mkdir (Get-Culture).DateTimeFormat.GetMonthName($mes) -WhatIf
}
```

## Crear directorios con los años desde 2020 hasta 2030 (opción 1)
```PowerShell
foreach($anio in 2020..2030)
{
    mkdir ($anio) -WhatIf
}
```

## Crear directorios con los años desde 2020 hasta 2030 (opción 2)
```PowerShell
mkdir (2020..2030) -WhatIf
```

## Crear directorios con los años desde 2020 hasta 2030 (opción 3)
```PowerShell
foreach($anio in 1..10)
{
    (Get-Date).AddYears($anio).Year
}
```

## En cada uno de los directorios anteriores, crea un subdirectorio con los meses del año
```PowerShell
foreach($anio in 2020..2030)
{
    mkdir ($anio)
    cd $anio
    foreach($mes in 1..12)
    {
        mkdir (Get-Culture).DateTimeFormat.GetMonthName($mes)
    }
    cd ..
}
```

## En cada mes, crear un directorio con cada día del mes
```PowerShell
foreach($anio in 2020..2030)
{
    mkdir ($anio)
    cd $anio
    foreach($mes in 1..12)
    {
        mkdir (Get-Culture).DateTimeFormat.GetMonthName($mes)
        cd $mes
        1..31 | %{mkdir $_}
        cd ..
    }
    cd ..
}
```

## Trabajar con fechas
```PowerShell
$mes = (get-date).Month
$ano = (get-date).year
$dia = (get-date).Day
mkdir $ano$mes$dia -WhatIf
```

## Trabajar con fechas (día anterior)
```PowerShell
$mes = (get-date).AddDays(-1).Month
$ano = (get-date).AddDays(-1).Year
$dia = (get-date).AddDays(-1).Day
mkdir $ano$mes$dia -WhatIf
```

## Trabajar con fechas (listar varios días)
```PowerShell
-1..-7
 
foreach($dias in (-1..-7))
{
    $dias
}
 
foreach($dias in (-1..-7))
{
    (Get-Date).AddDays($dias)
}
 
foreach($dias in (-1..-7))
{
    $mes = (get-date).AddDays($dias).Month
    $ano = (get-date).AddDays($dias).Year
    $dia = (get-date).AddDays($dias).Day
    mkdir $ano$mes$dia -WhatIf
}
```

## Hay un proceso que falla, revisad la información sobre servicios, procesos e hilos durante una semana (creando ficheros de registro varias veces al día)
 
### Parte 1
### -Crear la carpeta para cada día y para varios momentos del día

#### Solución rara (o no), calculando el número de horas
```PowerShell
foreach($dias in (1..168))
{
    $mes = (get-date).AddHours($dias).Month
    $ano = (get-date).AddHours($dias).Year
    $dia = (get-date).AddHours($dias).Day
    $horas = (get-date).AddHours($dias).Hour
    mkdir $ano$mes$dia$horas -WhatIf
}
```
#### Solución medio buena
```PowerShell
foreach($dias in (-1..7))
{
    $mes = (get-date).AddDays($dias).Month
    $ano = (get-date).AddDays($dias).Year
    $dia = (get-date).AddDays($dias).Day
    foreach($horas in 0..23)
    {
        mkdir $ano$mes$dia$horas -WhatIf
    }
}
```
#### Solución bastante buena
```PowerShell
foreach($dias in (-1..7))
{
    $mes = (get-date).AddDays($dias).Month
    $ano = (get-date).AddDays($dias).Year
    $dia = (get-date).AddDays($dias).Day
    mkdir $ano$mes$dia -WhatIf
   
    foreach($horas in 0..23)
    {
        $ruta = [String]$ano+[String]$mes+[String]$dia
        $ruta
        New-Item -Name $horas -Path $ruta -ItemType Directory -WhatIf
    }
}
```
#### Solución mucha locura
```PowerShell
foreach($dias in (-1..7))
{
    [String]$mes = (get-date).AddDays($dias).Month
    [String]$ano = (get-date).AddDays($dias).Year
    [String]$dia = (get-date).AddDays($dias).Day
    [String]$ruta0 = $ano+"\"+$mes+"\"+$dia
    mkdir $ruta0 -WhatIf
   
    foreach($horas in 0..23)
    {
        New-Item -Name $horas -Path $ruta0 -ItemType Directory -WhatIf
    }
}
```

### Parte 2
#### -Listar procesos
#### -Listar hilos
#### -Listar servicios

#### Solución que se ejecuta durante una semana (168 horas)
```PowerShell
foreach($veces in 168)
{
    $fecha = (Get-Date).ToString("yyyy\\MM\\dd")
    mkdir $fecha -Force
 
    $hora = (Get-Date).Hour
    New-Item -Name $hora -Path $fecha -ItemType Directory -Force
 
    (Get-Process).Name > ([String]($fecha+"\"+$hora+"\procesos.txt"))
    (Get-Service).Name > ([String]($fecha+"\"+$hora+"\servicios.txt"))
    (Get-Process).Threads > ([String]($fecha+"\"+$hora+"\hilos.txt"))
 
    Start-Sleep -Seconds 3600
}
```

#### Solución de Daniel Cebrián
```PowerShell
foreach($dias in (-1..7))
{
    [String]$mes = (get-date).AddDays($dias).Month
    [String]$ano = (get-date).AddDays($dias).Year
    [String]$dia = (get-date).AddDays($dias).Day
    [String]$ruta = $ano+"\"+$mes+"\"+$dia

    mkdir $ruta -Force

    foreach($horas in 0..23)
    {   
        New-Item -Name $horas -Path $ruta -ItemType Directory -Force
        [String]$procesos = (gps).name
        [String]$ruta1= ($ruta+"\"+$horas)
        New-Item -Name procesos.txt -Path $ruta1 -ItemType File -value $procesos -Force
    }
}
```
